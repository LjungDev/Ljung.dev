{"pageProps":{"siteMetainfo":{"headerTitle":"Ljung","headerSubtitle":".dev","pageTitlePrefix":"Ljung | "},"_site":{"globalSeo":{"siteName":"Ljung","fallbackSeo":{"title":"Ljung | Game Dev","description":"Indie Game Developer from Sweden ðŸŽ®"}}},"post":{"title":"Character Movement from Scratch pt 4: Gravity","description":"In this part we will implement gravity!","seriesPrevious":{"slug":"character-movement-from-scratch-pt-3-collision","seriesTitle":"pt 3: Collision"},"seriesNext":{"slug":"character-movement-from-scratch-pt-5-jumping","seriesTitle":"pt 5: Jumping"},"content":{"value":{"schema":"dast","document":{"type":"root","children":[{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"A project using this tutorial series is "},{"url":"https://github.com/LjungDev/Cactus","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"tracked on GitHub"}]},{"type":"span","value":". The revision after this part is "},{"url":"https://github.com/LjungDev/Cactus/commit/cacd857bfdc6c25f077d0e29ac80b73a7f53045a","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"cacd857"}]},{"type":"span","value":"."}]}]},{"type":"paragraph","children":[{"type":"span","value":"Hej!"}]},{"type":"paragraph","children":[{"type":"span","value":"In this part of the the tutorial series we will look at implementing gravity, and at the end we will have a our character move down slopes and fall down from edges!"}]},{"type":"paragraph","children":[{"type":"span","value":"Gravity is actually quite simple. It is simply a constant force being applied \"downwards\". For Unreal this is negative Z, but it can be anything you want (for example making a game with planets and their own gravity!)."}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"Disclaimer: I'm not that good at physics so things might not be physically accurate...but they don't have to be! The nice thing about games is that it only have to "},{"type":"span","marks":["emphasis"],"value":"seem"},{"type":"span","value":" realistic (or not). With that said, we'll try to make use of forces, velocity, acceleration etc. so that it hopefully makes sense."}]},{"type":"paragraph","children":[{"type":"span","value":"Also, for this tutorial we won't bother with drag (air resistance) or anything else besides the basics."}]}]},{"type":"paragraph","children":[{"type":"span","value":"First, since we're introducing an entirely new force unrelated to our input, we should rename our horizontal movement input for clarity and move the velocity update to the move section:"}]},{"code":"/** SimpleMovementComponent::TickComponent */\n\n...\n\n// Calculate input force\nconst FVector& Input = ConsumeInputVector().GetClampedToMaxSize2D(1.0f);\nconst FVector HorizontalMovement = Input * MoveSpeed;\n\n// Move\nconst FRotator& Rotation = UpdatedComponent->GetComponentRotation();\nVelocity += HorizontalMovement;\n\n...","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"The effect is the same but now we have a bit cleaner structure to work with."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Applying Gravity"}]},{"type":"paragraph","children":[{"type":"span","value":"From the movement component, gravity can be fetched by calling "},{"type":"span","marks":["code"],"value":"GetGravityZ()"},{"type":"span","value":". This is a nice helper that grabs the current gravity. This can be overridden per world but by default it uses the global gravity value set in Project Settings -> Engine -> Physics, which by default is "},{"type":"span","marks":["code"],"value":"-980.0"},{"type":"span","value":". Notice that it is already nicely expressed as a negative value, so we can multiply it with "},{"type":"span","marks":["code"],"value":"FVector::UpVector"},{"type":"span","value":" directly to get a downwards force."}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"Note: -980.0 is the same as Earths average gravitational acceleration expressed in Unreal units, equal to 9.8m/s^2."}]}]},{"type":"paragraph","children":[{"type":"span","value":"Let's add a section just before the move step where we calculate our vertical movement:"}]},{"code":"// Apply gravity\nconst float GravityForce = GetGravityZ();\nconst FVector VerticalMovement = FVector::UpVector * GravityForce;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And add it to our velocity in our move step:"}]},{"code":"Velocity += HorizontalMovement + VerticalMovement;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We also need to reset our Z velocity whenever we hit ground, otherwise it will constantly accumulate and cause lots of trouble, so set it to 0 within our hit check:"}]},{"code":"if (Hit.IsValidBlockingHit())\n{\n  Velocity.Z = 0;\n  \n  ...\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Now let's try it:"}]},{"item":"55445411","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"Ok, this kind of works...but we're falling way too fast. The reason? Well we've actually been cheating/simplifying how (horizontal) movement is implemented. "}]},{"type":"paragraph","children":[{"type":"span","value":"Both horizontal and vertical movement are represented by variables that correspond to cm/s we want to move. The difference is that gravity actually accumulates! In real life things don't immediately start falling at max speed. They "},{"type":"span","marks":["emphasis"],"value":"accelerate"},{"type":"span","value":"."}]},{"type":"paragraph","children":[{"type":"span","value":"Realizing this and analyzing the code we can actually see that we're adding the speed of 9.8m/s "},{"type":"span","marks":["emphasis"],"value":"every tick"},{"type":"span","value":". Instead we want to accumulate so that we roughly equal a speed of 9.8m/s "},{"type":"span","marks":["emphasis"],"value":"after 1 second"},{"type":"span","value":" (that is, 9.8m/s/s). The reason it's different with horizontal movement is that we're resetting XY velocity each frame (in thie "}]},{"type":"paragraph","children":[{"type":"span","value":"Luckily once we figure this out the fix is very simple; we just need to multiple our gravity force by "},{"type":"span","marks":["code"],"value":"DeltaTime"},{"type":"span","value":" one extra time:"}]},{"code":"const float GravityForce = GetGravityZ() * DeltaTime;\nconst FVector VerticalMovement = FVector::UpVector * GravityForce * DeltaTime;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We should now fall at a much more acceptable rate:"}]},{"item":"55445412","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"If you find this too slow or too fast you can always add an extra multiplier to "},{"type":"span","marks":["code"],"value":"GravityForce"},{"type":"span","value":" and tweak it to your liking."}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Terminal Velocity"}]},{"type":"paragraph","children":[{"type":"span","value":"An optional but recommended step is to also factor in terminal velocity. This means that we won't accumulate speed indefinitely and instead clamp our falling speed. To do that we simply grab our current physics volume and use its "},{"type":"span","marks":["code"],"value":"TerminalVelocity"},{"type":"span","value":". In case we're not in any specific physics volume it falls back to the global value set in Project Settings -> Engine -> Physics which by default is "},{"type":"span","marks":["code"],"value":"4000.0"},{"type":"span","value":". We can then clamp our velocity Z (after applying our movement):"}]},{"code":"const float TerminalVelocity = GetPhysicsVolume()->TerminalVelocity * DeltaTime;\n\n...\n\nVelocity += HorizontalMovement + VerticalMovement;\nVelocity.Z = FMath::Max(Velocity.Z, -TerminalVelocity);","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We also need to include the physics volume header at the top:"}]},{"code":"#include \"SimpleMovementComponent.h\"\n\n#include \"GameFramework/PhysicsVolume.h\"","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"Results"}]},{"item":"55445413","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"(I've added an on screen debug message to help visualize)"}]},{"type":"paragraph","children":[{"type":"span","value":"And, as an added bonus, we can now also walk down slopes (albeit a bit choppy - we will fix that later on!):"}]},{"item":"55445448","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"Our final tick function now looks like this:"}]},{"code":"void USimpleMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType,\n                                             FActorComponentTickFunction* ThisTickFunction)\n{\n  Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n  if (ShouldSkipUpdate(DeltaTime))\n  {\n    return;\n  }\n\n  if (!PawnOwner || !UpdatedComponent)\n  {\n    return;\n  }\n\n  // Reset velocity\n  Velocity.X = 0;\n  Velocity.Y = 0;\n\n  // Calculate force\n  const FVector& Input = ConsumeInputVector().GetClampedToMaxSize2D(1.0f);\n  const FVector HorizontalMovement = Input * MoveSpeed;\n\n  // Apply gravity\n  const float GravityForce = GetGravityZ();\n  const FVector VerticalMovement = FVector::UpVector * GravityForce * DeltaTime;\n\n  // Move\n  const FRotator& Rotation = UpdatedComponent->GetComponentRotation();\n  const float TerminalVelocity = GetPhysicsVolume()->TerminalVelocity;\n  Velocity += HorizontalMovement + VerticalMovement;\n  Velocity.Z = FMath::Max(Velocity.Z, -TerminalVelocity);\n  const FVector MovementDelta = Velocity * DeltaTime;\n\n  FHitResult Hit;\n  SafeMoveUpdatedComponent(MovementDelta, Rotation, true, Hit);\n\n  if (Hit.IsValidBlockingHit())\n  {\n    Velocity.Z = 0;\n    HandleImpact(Hit, DeltaTime, MovementDelta);\n    SlideAlongSurface(MovementDelta, 1.0f - Hit.Time, Hit.Normal, Hit, true);\n  }\n\n  UpdateComponentVelocity();\n}\n","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And that's it! Next up we will look at a more active application of gravity: jumping! ðŸª‚"}]}]}},"blocks":[{"__typename":"WebmRecord","id":"55445411","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"NZqtLbTqI0001QMr3snReeK702l8sKJcStn"}}},{"__typename":"WebmRecord","id":"55445412","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"WDsBJ4BzHdTvO8q5fUuyfmB49DqDaJQ4"}}},{"__typename":"WebmRecord","id":"55445413","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"JfzZ21jKy00Z801DZ02tDVYi6b01GwJ4GxnF"}}},{"__typename":"WebmRecord","id":"55445448","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"wYcfgYG22smLJWIru302U5uK2vtF007Q3F"}}}]}},"isPreview":false},"__N_SSG":true}