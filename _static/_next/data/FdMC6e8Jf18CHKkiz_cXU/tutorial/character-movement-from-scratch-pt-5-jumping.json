{"pageProps":{"siteMetainfo":{"headerTitle":"Ljung","headerSubtitle":".dev","pageTitlePrefix":"Ljung | "},"_site":{"globalSeo":{"siteName":"Ljung","fallbackSeo":{"title":"Ljung | Game Dev","description":"Indie Game Developer from Sweden ðŸŽ®"}}},"post":{"title":"Character Movement from Scratch pt 5: Jumping","description":"Here we'll look at jumping, and state machines.","seriesPrevious":{"slug":"character-movement-from-scratch-pt-4-gravity","seriesTitle":"pt 4: Gravity"},"seriesNext":null,"content":{"value":{"schema":"dast","document":{"type":"root","children":[{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"A project using this tutorial series is "},{"url":"https://github.com/LjungDev/Cactus","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"tracked on GitHub"}]},{"type":"span","value":". The revision after this part is "},{"url":"https://github.com/LjungDev/Cactus/commit/0a7652301f4c68c70d483575f35c7ab2bd41ef76","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"0a76523"}]},{"type":"span","value":"."}]}]},{"type":"paragraph","children":[{"type":"span","value":"Hej!"}]},{"type":"paragraph","children":[{"type":"span","value":"With gravity done implementing jumping is theoretically easy; just add a force upwards for one tick and let gravity handle the rest. In practice however, with our current code, there is much to be done."}]},{"type":"paragraph","children":[{"type":"span","value":"The main problem is that we do a ground check every tick, and because of how jumping works we'll probably just zero out our vertical velocity as soon as we start jumping."}]},{"type":"paragraph","children":[{"type":"span","value":"Of course, this can be solved with more code, but it quickly gets messy if we don't think about our architecture. Luckily, there's a very common code pattern that can be used to solve this: State Machines!"}]},{"type":"heading","level":1,"children":[{"type":"span","value":"State Machine"}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Concept"}]},{"type":"paragraph","children":[{"type":"span","value":"If you're unfamiliar with State Machines it is very simple. Given a set of distinct abstract \"states\" (e.g. \"Walking\", \"Falling\", \"Swimming\" etc.) we switch between which set of code we use based on a single variable called \"the current state\", which can only be one of the state at a time."}]},{"type":"paragraph","children":[{"type":"span","value":"The current state is changed based on \"transitions\" - conditions in each state that causes it to enter another state. For example, if we're \"Walking\" and we suddenly have no ground, we're now \"Falling\"."}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"The built-in "},{"type":"span","marks":["code"],"value":"CharacterMovementComponent"},{"type":"span","value":" actually use this pattern! As well as many other concepts in game development like AI."}]}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Code"}]},{"type":"paragraph","children":[{"type":"span","value":"Based on this, we should introduce two states, \"Walking\" and \"Falling\". Both states share similar functionality (for example both consume and apply horizontal movement) but they differ slightly. I've made a diagram that outline the basic states and functions we're going to refactor/use:"}]},{"item":"55480729","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"Blue elements represent common functionality between the states, and circles are state transitions."}]},{"type":"paragraph","children":[{"type":"span","value":"To support this, we're going to rewrite most of our movement component, but let's start with the state machine. We're going to use an Enum to hold our possible states, a variable with our current state, and two functions for walking and falling respectively."}]},{"type":"paragraph","children":[{"type":"span","value":"To our movement component header let's add above our class declaration:"}]},{"code":"UENUM()\nenum EMovementState\n{\n  Walking,\n  Falling\n};","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And inside our class declaration, after our tick function let's add:"}]},{"code":"private:\n  EMovementState MovementState;\n\n  void DoMovement_Walking(const float DeltaTime);\n  void DoMovement_Falling(const float DeltaTime);","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"To keep things nice and functional we'll provide the "},{"type":"span","marks":["code"],"value":"DeltaTime"},{"type":"span","value":" for them to avoid having to grab it elsewhere."}]},{"type":"paragraph","children":[{"type":"span","value":"In our cpp file inside "},{"type":"span","marks":["code"],"value":"TickComponent"},{"type":"span","value":" we'll remove everything after our velocity reset and replace with the state check and functions:"}]},{"code":"...\n\nswitch (MovementState)\n{\ncase Walking:\n  DoMovement_Walking(DeltaTime);\n  break;\ncase Falling:\n  DoMovement_Falling(DeltaTime);\n  break;\n}\n\nUpdateComponentVelocity();","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And that's all for the state machine itself! However we're now missing our walking/falling functionality, but before that we need to implement some additional functions."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Desired Input"}]},{"type":"paragraph","children":[{"type":"span","value":"Since both Walking and Falling want to use desired (horizontal) input we will move that into a separate function to avoid code duplication. We'll however omit the "},{"type":"span","marks":["code"],"value":"ConsumeInputVector"},{"type":"span","value":" call from that since that directly modifies a class variable, and we want to keep our functions as pure as possible. Instead we'll provide the input vector as a function parameter."}]},{"type":"paragraph","children":[{"type":"span","value":"In our header file, below our "},{"type":"span","marks":["code"],"value":"MovemenState"},{"type":"span","value":" variable, add:"}]},{"code":"FVector GetDesiredInputMovement(const FVector InputVector) const;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And add the implementation, which is just our horizontal movement calculation from before:"}]},{"code":"FVector USimpleMovementComponent::GetDesiredInputMovement(const FVector InputVector) const\n{\n  const FVector& Input = InputVector.GetClampedToMaxSize2D(1.0f);\n  const FVector Movement = Input * MoveSpeed;\n  return Movement;\n}","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"Move"}]},{"type":"paragraph","children":[{"type":"span","value":"The Move function will perform the bulk of our previous functionality. The function will take "},{"type":"span","marks":["code"],"value":"DeltaTime"},{"type":"span","value":" and return if we hit something, as well as output the hit result."}]},{"type":"paragraph","children":[{"type":"span","value":"In our header we add the declaration just above our "},{"type":"span","marks":["code"],"value":"DoMovement"},{"type":"span","value":" functions:"}]},{"code":"bool Move(FHitResult& OutInitialHit, const float DeltaTime);","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And for our definition we basically do the same as our previous tick function, with added handling for the return values:"}]},{"code":"bool USimpleMovementComponent::Move(FHitResult& OutInitialHit, const float DeltaTime)\n{\n  const FRotator& Rotation = UpdatedComponent->GetComponentRotation();\n  const FVector MovementDelta = Velocity * DeltaTime;\n\n  SafeMoveUpdatedComponent(MovementDelta, Rotation, true, OutInitialHit);\n\n  if (OutInitialHit.IsValidBlockingHit())\n  {\n    HandleImpact(OutInitialHit, DeltaTime, MovementDelta);\n\n    FHitResult Hit(OutInitialHit);\n    SlideAlongSurface(MovementDelta, 1.0f - OutInitialHit.Time, OutInitialHit.Normal, Hit, true);\n\n    return true;\n  }\n  return false;\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Note that we copy the hit result to use with "},{"type":"span","marks":["code"],"value":"SlideAlongSurface"},{"type":"span","value":", because it may modify the hit result in turn, and we are only interested in the initial hit for additional handling later."}]},{"type":"paragraph","children":[{"type":"span","value":"We also no longer reset our Z velocity as that is specific to the "},{"type":"span","marks":["code"],"value":"Falling"},{"type":"span","value":" state."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Ground Check"}]},{"type":"paragraph","children":[{"type":"span","value":"This is where it becomes a bit more complex, as we cannot use the same hit check for ground as we have for "},{"type":"span","marks":["code"],"value":"Move"},{"type":"span","value":", since you might move upwards or collide with a wall. Instead we need to manually implement a similar function that sweeps the world and checks for ground."}]},{"type":"paragraph","children":[{"type":"span","value":"The function signature is simple enough; return a "},{"type":"span","marks":["code"],"value":"bool"},{"type":"span","value":" and hit result similar to the "},{"type":"span","marks":["code"],"value":"Move"},{"type":"span","value":" function. In our header about the "},{"type":"span","marks":["code"],"value":"Move"},{"type":"span","value":" function add:"}]},{"code":"bool CheckForGround(FHitResult& OutHit) const;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"The internals involve a bit more lines though."}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Collider Reference"}]},{"type":"paragraph","children":[{"type":"span","value":"Manual collision checking is done with either line traces or shape sweeps. In our case we'll do a shape sweep that mimics the same shape as our collider. Our movement component doesn't know about our capsule collider however, so we need keep a reference to it."}]},{"type":"paragraph","children":[{"type":"span","value":"In our header just above our "},{"type":"span","marks":["code"],"value":"MovementState"},{"type":"span","value":" variable add:"}]},{"code":"UPROPERTY()\nUCapsuleComponent* UpdatedCollider;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And above our "},{"type":"span","marks":["code"],"value":"TickComponent"},{"type":"span","value":" we need to add an override for "},{"type":"span","marks":["code"],"value":"BeginPlay"},{"type":"span","value":" to grab our collider:"}]},{"code":"\nvirtual void BeginPlay() override;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Then in our cpp file add the capsule collider header:"}]},{"code":"\n#include \"Components/CapsuleComponent.h\"","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And implement the "},{"type":"span","marks":["code"],"value":"BeginPlay"},{"type":"span","value":" function like so:"}]},{"code":"void USimpleMovementComponent::BeginPlay()\n{\n  Super::BeginPlay();\n\n  UpdatedCollider = Cast<UCapsuleComponent>(UpdatedComponent);\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We should now have a capsule collider reference in runtime to work with."}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Sweep"}]},{"type":"paragraph","children":[{"type":"span","value":"A shape sweep requires a few parameters:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Start location"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"End location"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Rotation"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Collision channel"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Shape"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Query/response parameters"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"Most of these can be extracted from our capsule collider, however we need to take note that locations are based on the center point of the shape (not the base)."}]},{"type":"paragraph","children":[{"type":"span","value":"We'll start of the GroundCheck function by checking if we have our UpdatedCollider:"}]},{"code":"bool USimpleMovementComponent::CheckForGround(FHitResult& OutHit) const\n{\n  if (!UpdatedCollider)\n  {\n    return false;\n  }","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Next we setup some constants and calculate our start and end sweep location:"}]},{"code":"constexpr static float ZOffset = 5.0f;\nconst FVector Offset = FVector::UpVector * ZOffset;\nconst FVector ColliderLocation = UpdatedCollider->GetComponentLocation();\nconst FVector StartLocation = ColliderLocation;\nconst FVector EndLocation = ColliderLocation - Offset;","type":"code","language":"cpp"},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"constexpr static"},{"type":"span","value":" is just an optimization for a purely constant value, but you can also make this a regular "},{"type":"span","marks":["code"],"value":"UPROPERTY"},{"type":"span","value":" if you intend to tweak it a lot."}]}]},{"type":"paragraph","children":[{"type":"span","value":"Next, we setup our sweep configuration. We need four things:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"FCollisionQueryParams which we use to make sure we don't self-collide"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"FCollisionResponseParams which controls a few extra flags, that we copy directly from our collider"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"FCollisionShape with the correct capsule shape, which we just grab from our collider as well"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"ECollisionChannel value that tells what to collide against, also provided by the collider"}]}]}]},{"code":"FCollisionQueryParams SweepParams;\nSweepParams.AddIgnoredActor(UpdatedCollider->GetOwner());\n\nFCollisionResponseParams ResponseParams;\nUpdatedCollider->InitSweepCollisionParams(SweepParams, ResponseParams);\n\nFCollisionShape SweepShape = UpdatedCollider->GetCollisionShape();\nconst ECollisionChannel CollisionChannel = UpdatedCollider->GetCollisionObjectType();","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Finally we perform the sweep using the world object, and return if we hit or not:"}]},{"code":"bool bDidHit = GetWorld()->SweepSingleByChannel(\n  OutHit, StartLocation, EndLocation, FQuat::Identity, CollisionChannel, SweepShape, SweepParams,\n  ResponseParams);\n\nreturn bDidHit;","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"State: Walking"}]},{"type":"paragraph","children":[{"type":"span","value":"Our walking function is quite simply now since we've refactored a lot of the code into functions. It is about the same as our previous code, with the addition of changing state to Falling when we aren't grounded anymore:"}]},{"code":"void USimpleMovementComponent::DoMovement_Walking(const float DeltaTime)\n{\n  const FVector InputVector = ConsumeInputVector();\n  const FVector HorizontalMovement = GetDesiredInputMovement(InputVector);\n  Velocity += HorizontalMovement;\n\n  FHitResult Hit;\n  Move(Hit, DeltaTime);\n\n  const bool bIsGrounded = CheckForGround(Hit);\n  \n  if (!bIsGrounded)\n  {\n    MovementState = Falling;\n  }\n}","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"State: Falling"}]},{"type":"paragraph","children":[{"type":"span","value":"Our Falling function is similar to our Walking function with the additional code for apply gravity and state change. If you go back to the diagram you'll also see that we need to handle hitting the ceiling, otherwise some interesting oddities will happen."}]},{"type":"paragraph","children":[{"type":"span","value":"To check for ceiling we first check if we hit something, and we're moving upwards ("},{"type":"span","marks":["code"],"value":"Velocity.Z > 0"},{"type":"span","value":"), then grab the dot product of the impact normal and check the angle to see if we hit a flat ceiling, and stop if we do."}]},{"type":"paragraph","children":[{"type":"span","value":"If you're unfamiliar with the concepts, the impact normal is a vector that points straight out from the surface we hit, the dot product is a value that tells how close two vectors (like our normal and straight down) are rotation-wise, and to get the angle (in radians) we get the arc-cosine of the value."}]},{"code":"void USimpleMovementComponent::DoMovement_Falling(const float DeltaTime)\n{\n  const FVector InputVector = ConsumeInputVector();\n  const FVector HorizontalMovement = GetDesiredInputMovement(InputVector);\n\n  // Apply gravity\n  const float GravityForce = GetGravityZ();\n  const FVector VerticalMovement = FVector::UpVector * GravityForce * DeltaTime;\n  const float TerminalVelocity = GetPhysicsVolume()->TerminalVelocity;\n\n  Velocity += HorizontalMovement + VerticalMovement;\n  Velocity.Z = FMath::Max(Velocity.Z, -TerminalVelocity);\n\n  FHitResult Hit;\n  bool bDidHit = Move(Hit, DeltaTime);\n\n  // Check if we hit ceiling\n  if (bDidHit && Velocity.Z > 0)\n  {\n    const float Dot = Hit.ImpactNormal.Dot(-FVector::UpVector);\n    const float Angle = FMath::Acos(Dot);\n    const float StopAngleInRadians = FMath::DegreesToRadians(MaxCeilingStopAngle);\n    if (Angle <= StopAngleInRadians)\n    {\n      Velocity.Z = 0;\n    }\n  }\n\n  const bool bIsGrounded = CheckForGround(Hit);\n  if (bIsGrounded && Velocity.Z <= 0)\n  {\n    MovementState = Walking;\n    Velocity.Z = 0;\n  }\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"For the ceiling check I've extracted the angle into a "},{"type":"span","marks":["code"],"value":"UPROPERTY"},{"type":"span","value":" value called "},{"type":"span","marks":["code"],"value":"MaxCeilingStopAngle"},{"type":"span","value":" and set its default to 5.0f, so we hit a ceiling the angle of the hit is within 5 degrees of straight up."}]},{"type":"paragraph","children":[{"type":"span","value":"For our state change we also check that we're moving downwards so we don't accidentally snap when for example jumping over something."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Jumping!"}]},{"type":"paragraph","children":[{"type":"span","value":"And that leads us (finally!) to jumping. As with any action we need to setup the input. "}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Input"}]},{"type":"paragraph","children":[{"type":"span","value":"In our "},{"type":"span","marks":["code"],"value":"CactusPlayerPawn"},{"type":"span","value":" (or your equivalent) we add an input action (next the other input actions):"}]},{"code":"UPROPERTY(EditDefaultsOnly, Category=\"Input\")\nUInputAction* JumpAction;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And a function declaration (below our other input functions):"}]},{"code":"void OnInput_Jump();","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"For our implementation the input binding is the same as the others (in "},{"type":"span","marks":["code"],"value":"SetupPlayerInputComponent"},{"type":"span","value":"):"}]},{"code":"PlayerEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Triggered, this,\n                                         &ACactusPlayerPawn::OnInput_Jump);","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And the jump function will just trigger the jump on our movement component, which we'll setup soon:"}]},{"code":"void ACactusPlayerPawn::OnInput_Jump()\n{\n  MovementComponent->Jump();\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"For the input action, since jump is always a \"press\" and not a \"hold\" like the other inputs, we also add a trigger with \"Pressed\" to it:"}]},{"item":"55485512","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"We add the action to our input mapping context and set our desired input keys:"}]},{"item":"55485513","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"Don't forget to set the input action reference in our Pawn BP!"}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Movement Code"}]},{"type":"paragraph","children":[{"type":"span","value":"The movement component header needs two things: a jump force variable, and a jump function (both "},{"type":"span","marks":["code"],"value":"public"},{"type":"span","value":"):"}]},{"code":"public:\n\n  ...\n\n  UPROPERTY(EditAnywhere, Category=\"Movement\")\n  float JumpForce;\n\n  ...\n\n  void Jump();","type":"code","language":"cpp"},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"I've set the default value of "},{"type":"span","marks":["code"],"value":"JumpForce"},{"type":"span","value":" in the constructor to 420.0f as a homage to the same default in the built-in character movement component."}]}]},{"type":"paragraph","children":[{"type":"span","value":"And finally finally, the implementation of the jump function we're we simply check if we're Walking, add our jump force, and move to Falling:"}]},{"code":"void USimpleMovementComponent::Jump()\n{\n  if (MovementState == Walking)\n  {\n    Velocity.Z += JumpForce;\n    MovementState = Falling;\n  }\n}","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"Results"}]},{"type":"paragraph","children":[{"type":"span","value":"All that refactoring for our 5 lines worth of jump code gives us the ability to jump!"}]},{"item":"55485514","type":"block"},{"type":"heading","level":2,"children":[{"type":"span","value":"Ceiling"}]},{"type":"paragraph","children":[{"type":"span","value":"We should also stop when we hit a flat-ish ceiling, but slide along any angled ceilings:"}]},{"item":"55485520","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"Interestingly, because of how "},{"type":"span","marks":["code"],"value":"SlideAlongSurface"},{"type":"span","value":" works, we also slightly brake (proportional to the normal) when we hit a slope, giving us somewhat natural physics:"}]},{"item":"55485521","type":"block"}]}},"blocks":[{"__typename":"ImageRecord","id":"55480729","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLChULFg4OFRUNDh0TFgUMFxUZGBYVIhUiKzcvGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0NFQ8NHDscFh0vLy8vLy87Oy8vLy8vLy8vLy8vLy87Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAcAGAMBIgACEQEDEQH/xAAXAAEAAwAAAAAAAAAAAAAAAAAAAgMH/8QAHBAAAgICAwAAAAAAAAAAAAAAAAMBAgVCBDFB/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAwDAQACEQMRAD8A19nKWuPZK65BdtZABUW5Ki+qgAJX/9k=","srcSet":"https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.25&max-w=600 505w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.5&max-w=600 1010w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.75&max-w=600 1515w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&max-w=600 2021w","webpSrcSet":"https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.25&fm=webp&max-w=600 505w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.5&fm=webp&max-w=600 1010w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&dpr=0.75&fm=webp&max-w=600 1515w,https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&fm=webp&max-w=600 2021w","sizes":"(max-width: 2021px) 100vw, 2021px","src":"https://www.datocms-assets.com/77616/1662824665-fpmfs-pt5-jump-state-machine.png?auto=format&max-w=600","alt":null,"title":null,"width":2021,"height":511,"aspectRatio":3.954990215264188}}},{"__typename":"ImageRecord","id":"55485512","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBw0SBhMLDQgIBwcNDg4QBwcGBxEJDQgYFx8ZGBYVFhUaHysjGh0oHSEiJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OFQ0NFS8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABUAGAMBIgACEQEDEQH/xAAaAAADAAMBAAAAAAAAAAAAAAAAAwQCBQYB/8QAHBABAAIBBQAAAAAAAAAAAAAAAAIDIQERIjEy/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDir5cWts9K7Z4S7ZSLloGU3iCqfRQCJdgAIf/Z","srcSet":"https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.25&max-w=600 117w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.5&max-w=600 234w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.75&max-w=600 351w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&max-w=600 469w","webpSrcSet":"https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.25&fm=webp&max-w=600 117w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.5&fm=webp&max-w=600 234w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&dpr=0.75&fm=webp&max-w=600 351w,https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&fm=webp&max-w=600 469w","sizes":"(max-width: 469px) 100vw, 469px","src":"https://www.datocms-assets.com/77616/1663007819-fpmfs-pt5-input-action-jump.png?auto=format&max-w=600","alt":null,"title":null,"width":469,"height":410,"aspectRatio":1.1439024390243901}}},{"__typename":"ImageRecord","id":"55485513","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBxAHBhUNCAgNDQcNDg8OBQgNDhYNDQcNFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0NEA0NEC8cFh0vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFQMBIgACEQEDEQH/xAAZAAEBAAMBAAAAAAAAAAAAAAAABAMFBgH/xAAcEAEAAQUBAQAAAAAAAAAAAAAAAQIDERIhEwT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAMAwEAAhEDEQA/AOI+qdqWv8+rbk5hjwQQ12s1CyaegM13kJt+vQDYAH//2Q==","srcSet":"https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.25&max-w=600 134w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.5&max-w=600 269w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.75&max-w=600 403w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&max-w=600 538w","webpSrcSet":"https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.25&fm=webp&max-w=600 134w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.5&fm=webp&max-w=600 269w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&dpr=0.75&fm=webp&max-w=600 403w,https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&fm=webp&max-w=600 538w","sizes":"(max-width: 538px) 100vw, 538px","src":"https://www.datocms-assets.com/77616/1663007966-fpmfs-pt5-input-mapping.png?auto=format&max-w=600","alt":null,"title":null,"width":538,"height":606,"aspectRatio":0.8877887788778878}}},{"__typename":"WebmRecord","id":"55485514","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"D23CM900J0202jh00J6V7oUryb3QmqwcrUId"}}},{"__typename":"WebmRecord","id":"55485520","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"2Hg8OL2dD7KbspthYWTOpg2BePKT9YVJ"}}},{"__typename":"WebmRecord","id":"55485521","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"qiuE02FCeyAwDLT01nP1HU9TK96QNNSxG6"}}}]}},"isPreview":false},"__N_SSG":true}