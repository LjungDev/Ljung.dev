{"pageProps":{"siteMetainfo":{"headerTitle":"Ljung","headerSubtitle":".dev","pageTitlePrefix":"Ljung | "},"_site":{"globalSeo":{"siteName":"Ljung","fallbackSeo":{"title":"Ljung | Game Dev","description":"Indie Game Developer from Sweden ðŸŽ®"}}},"post":{"title":"Character Movement from Scratch pt 2: Basic Movement","description":"In this part we implement input handling and very basic movement.","seriesPrevious":{"slug":"character-movement-from-scratch-pt-1-introduction-and-setup","seriesTitle":"pt 1: Introduction and Setup"},"seriesNext":{"slug":"character-movement-from-scratch-pt-3-collision","seriesTitle":"pt 3: Collision"},"content":{"value":{"schema":"dast","document":{"type":"root","children":[{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"Note: Any code shown is made with Unreal Engine in mind, but the general concepts should be applicable to most 3D-engines."}]}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"A project using this tutorial series is "},{"url":"https://github.com/LjungDev/Cactus","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"tracked on GitHub"}]},{"type":"span","value":". The revision after this part is "},{"url":"https://github.com/LjungDev/Cactus/commit/82350b1802a76d11891753d2e8c0f93f0cab6367","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"82350b1"}]},{"type":"span","value":"."}]}]},{"type":"paragraph","children":[{"type":"span","value":"Hej!"}]},{"type":"paragraph","children":[{"type":"span","value":"In this first part of diving into the movement code, we'll be implementing basic forward/backward/strafing movement as well as camera look. We still have some input-handling boilerplate to go through but we'll start with just the bare minimum so no collision or gravity yet."}]},{"type":"paragraph","children":[{"type":"span","value":"It is fairly straightforward. The logic goes:"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Grab our desired input in a format we can understand"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Translate that input into a direction that is relative to the player pawn's rotation"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Pass the input to the movement component"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Consume the input in the movement component"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Derive a world-space delta to apply based on input and movement speed"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Move our player pawn by the calculated delta"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"The first part is probably the more complex as we have to setup our input bindings first."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Input Bindings"}]},{"type":"paragraph","children":[{"type":"span","value":"This section will double down as a crash course in Enhanced Input. Without going into too much detail, the main difference between Enhanced Input and a traditional input binding that you might be familiar with is that Enhanced Input takes common operations that are usually expressed in code and abstracts them into configurable objects. Things like handling raw input, deadzones, hold time, rapid firing etc. can be customized through dropdowns instead of code."}]},{"type":"paragraph","children":[{"type":"span","value":"You can read more about it on "},{"url":"https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Input/EnhancedInput/","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"the docs here"}]},{"type":"span","value":"."}]},{"type":"paragraph","children":[{"type":"span","value":"An abstract action that we want to handle (\"move\", \"jump\", \"shoot\") are configured as Input Action objects. The object that binds concrete input (e.g. the \"W\" key) to an action is an Input Mapping Context object. There are some extra layers to this but that is what we're going to use in our basic scenario. "}]},{"type":"paragraph","children":[{"type":"span","value":"We need two input actions: Move, and Look."}]},{"type":"paragraph","children":[{"type":"span","value":"Right-click an area of your choice in the Content Drawer and add two actions:"}]},{"item":"55082369","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"I named them "},{"type":"span","marks":["code"],"value":"IA_Move"},{"type":"span","value":" and "},{"type":"span","marks":["code"],"value":"IA_Look"},{"type":"span","value":". "}]},{"type":"paragraph","children":[{"type":"span","value":"Open "},{"type":"span","marks":["code"],"value":"IA_Move"},{"type":"span","value":" and set "},{"type":"span","marks":["code"],"value":"Value Type"},{"type":"span","value":" to "},{"type":"span","marks":["code"],"value":"Axis2D (Vector2D)"},{"type":"span","value":". "}]},{"type":"paragraph","children":[{"type":"span","value":"Do the same for "},{"type":"span","marks":["code"],"value":"IA_Look"},{"type":"span","value":"."}]},{"type":"paragraph","children":[{"type":"span","value":"Next right-click again and create an Input Mapping Context object. I named mine "},{"type":"span","marks":["code"],"value":"IMC_Default"},{"type":"span","value":"."}]},{"type":"paragraph","children":[{"type":"span","value":"Open it and add a mapping for "},{"type":"span","marks":["code"],"value":"IA_Move"},{"type":"span","value":". Then add control bindings for whatever inputs you want to handle. For this tutorial I'm adding WASD and "},{"type":"span","marks":["code"],"value":"Gamepad Left Thumbstick 2D-Axis"},{"type":"span","value":". The idea is to make input mappings so that the final value (the Vector2D value type) has X representing forward (positive) and backward (negative) movement, and Y representing right (positive) and left (negative) movement. To accomplish this for WASD we need to add a few swizzles and negates which is out of this scope, but the result should look like this:"}]},{"item":"55423801","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"(Dead zone is added to prevent the neutral position from drifting for gamepads.)"}]},{"type":"paragraph","children":[{"type":"span","value":"Add another mapping entry for IA_Look. This entry is much simpler as we can directly use the input values for mouse XY and the right thumbstick for gamepads. The idea here is that the X-axis represents yaw (left-right) and the Y-axis represents pitch (up-down). It should look like this:"}]},{"item":"55082371","type":"block"},{"type":"heading","level":1,"children":[{"type":"span","value":"Input Handling"}]},{"type":"paragraph","children":[{"type":"span","value":"We can now move over to the code that will utilize these objects."}]},{"type":"paragraph","children":[{"type":"span","value":"First, to access Enhanced Input in C++ we need to add it to our build script. Open your Build.cs (mine is located as "},{"type":"span","marks":["code"],"value":"Source/Cactus/Cactus.Build.cs"},{"type":"span","value":") and add \"EnhancedInput\" to the public dependencies:"}]},{"code":"PublicDependencyModuleNames.AddRange(new string[]\n  {\"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"EnhancedInput\"});","type":"code","language":"csharp"},{"type":"paragraph","children":[{"type":"span","value":"(You may need to regenerate project files after doing this.)"}]},{"type":"paragraph","children":[{"type":"span","value":"Next, we need to do the following things:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Setup the Input Mapping Context object in the controller class"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Add the input actions as "},{"type":"span","marks":["code"],"value":"UPROPERTY"},{"type":"span","value":" fields so we can set them from the editor"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Add an empty (for now) Move and Look function"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Override "},{"type":"span","marks":["code"],"value":"SetupPlayerInputComponent"},{"type":"span","value":" to handle binding the actions to code"}]}]}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Input Mapping Context"}]},{"type":"paragraph","children":[{"type":"span","value":"The idea (I think) behind mapping contexts is that you can have different contexts depending on what your doing (main gameplay, pause menu, spectator etc.) that can alter how you handle inputs. For our scenario we'll stick with a single one, and we'll let the Player Controller handle it since it seems appropriate."}]},{"type":"paragraph","children":[{"type":"span","value":"We need a property for the Input Mapping Context object that we can set from the editor, and we need to handle using it in our "},{"type":"span","marks":["code"],"value":"BeginPlay"},{"type":"span","value":" function which is called at the start of the game. In your player controller header file add to the class:"}]},{"code":"public:\n  UPROPERTY(EditDefaultsOnly)\n  class UInputMappingContext* DefaultInputMappingContext;\n  \nprotected:\n  virtual void BeginPlay() override;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Then we add the "},{"type":"span","marks":["code"],"value":"BeginPlay"},{"type":"span","value":" implementation where we fetch the Enhanced Input subsytem and set our context (we also need to include the relevant header):"}]},{"code":"#include \"CactusPlayerController.h\"\n\n#include \"EnhancedInputSubsystems.h\"\n\nvoid ACactusPlayerController::BeginPlay()\n{\n  Super::BeginPlay();\n\n  if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(\n    GetLocalPlayer()))\n  {\n    Subsystem->ClearAllMappings();\n    Subsystem->AddMappingContext(DefaultInputMappingContext, 0);\n  }\n}\n","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"That's it for the Player Controller class. Don't forget to set the context object ("},{"type":"span","marks":["code"],"value":"IMC_Default"},{"type":"span","value":") in your Player Controller BP!"}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Input Action fields"}]},{"type":"paragraph","children":[{"type":"span","value":"Next up we need to add two fields of type "},{"type":"span","marks":["code"],"value":"UInputAction*"},{"type":"span","value":" for the move action and look action. Inside your player pawn header file add:"}]},{"code":"UPROPERTY(EditDefaultsOnly, Category=\"Input\")\nUInputAction* MoveAction;\n\nUPROPERTY(EditDefaultsOnly, Category=\"Input\")\nUInputAction* LookAction;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"I've added them just below the component declarations, within the public scope. We also need to have "},{"type":"span","marks":["code"],"value":"UInputAction"},{"type":"span","value":" accessible. I like to forward declare them however you can also import the action header file. Above my player pawn class definition add:"}]},{"code":"class UInputAction;","type":"code","language":"cpp"},{"type":"heading","level":2,"children":[{"type":"span","value":"Stub functions"}]},{"type":"paragraph","children":[{"type":"span","value":"We need to add two functions, one for Move and one for Look. We'll implement them soon but for now we just need to get the input handling out of the way. In your pawn header add the functions to the class:"}]},{"code":"private:\n  void OnInput_Move(const FInputActionValue& Value);\n  void OnInput_Look(const FInputActionValue& Value);","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We also need to forward declare "},{"type":"span","marks":["code"],"value":"FInputActionValue"},{"type":"span","value":":"}]},{"code":"struct FInputActionValue;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Then add the empty implementations to the cpp file. Optionally you can also log the input value to verify that the bindings work later on:"}]},{"code":"void ACactusPlayerPawn::OnInput_Move(const FInputActionValue& Value)\n{\n  UE_LOG(LogTemp, Log, TEXT(\"Move: %s\"), *Value.Get<FVector2D>().ToString());\n}\n\nvoid ACactusPlayerPawn::OnInput_Look(const FInputActionValue& Value)\n{\n  UE_LOG(LogTemp, Log, TEXT(\"Look: %s\"), *Value.Get<FVector2D>().ToString());\n}","type":"code","language":"cpp"},{"type":"heading","level":2,"children":[{"type":"span","value":"SetupPlayerInputComponent"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"SetupPlayerInputComponent"},{"type":"span","value":" comes from Pawn and is a protected virtual function that is called when it is time to setup any input bindings (looking at the Unreal source it probably during "},{"type":"span","marks":["code"],"value":"APawn::PawnClientRestart"},{"type":"span","value":")."}]},{"type":"paragraph","children":[{"type":"span","value":"We need to override it and add our own bindings. The base implementation is empty, but we can still call the "},{"type":"span","marks":["code"],"value":"Super"},{"type":"span","value":" variant in case that ever changes. Binding actions is similar to the built-in way except we cast the input component to the Enhanced Input variant, so it accepts our input action objects."}]},{"type":"paragraph","children":[{"type":"span","value":"In the pawn header file add:"}]},{"code":"protected:\n  virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"And for the cpp file add:"}]},{"code":"void ACactusPlayerPawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n  Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n  UEnhancedInputComponent* PlayerEnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent);\n  if (PlayerEnhancedInputComponent)\n  {\n    PlayerEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this,\n                                             &ACactusPlayerPawn::OnInput_Move);\n    PlayerEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this,\n                                             &ACactusPlayerPawn::OnInput_Look);\n  }\n}","type":"code","language":"cpp"},{"type":"heading","level":2,"children":[{"type":"span","value":"Testing"}]},{"type":"paragraph","children":[{"type":"span","value":"Everything should be ready to accept input now. Don't forget to assign the Input Mapping Context object in the Player Controller BP, and the inputs actions in the Pawn BP. If you added the log statements to the Move and Look function, try pressing WASD and moving the mouse. You should see output similar to this:"}]},{"item":"55258791","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"The inputs should give these values:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"W should give X=1 Y=0"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"S should give X=-1 Y=0"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"A should give X=0 Y=-1"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"D should give X=0 Y=1"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Dragging the mouse up should give positive Y"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Dragging the mouse down should give negative Y"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Dragging the mouse right should give positive X"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Dragging the mouse left should give negative X"}]}]}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Look function"}]},{"type":"paragraph","children":[{"type":"span","value":"We'll cover the look function first since it's simple. It involves some math but is unrelated to most things we will deal with later on."}]},{"type":"paragraph","children":[{"type":"span","value":"First we add some editor-exposed variables to adjust how our camera look works. In the pawn header add:"}]},{"code":"UPROPERTY(EditAnywhere, Category=\"Input\")\nFVector2D CameraSensitivity;\n\nUPROPERTY(EditAnywhere, Category=\"Input\")\nFVector2D CameraPitchRange;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We should also set sensible defaults in our constructor in the cpp file:"}]},{"code":"ACactusPlayerPawn::ACactusPlayerPawn(): CameraSensitivity(FVector2D(180.0f, 90.0f)),\n                                        CameraPitchRange(FVector2D(-80.0f, 80.0f))\n{\n  ...\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Next, we implement the Look function. The logic goes:"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Grab our FVector2D value"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Multiply it by the camera sensitivity and delta time"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Calculate a new pitch (up and down) value, clamped between our range"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Set the cameras rotation to use the new pitch"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Calculate a new yaw (left and right) value based on actor rotation"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Set actor rotation to use new yaw"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"The code looks like this:"}]},{"code":"void ACactusPlayerPawn::OnInput_Look(const FInputActionValue& Value)\n{\n  const FVector2D VectorValue = Value.Get<FVector2D>() * CameraSensitivity * GetWorld()->GetDeltaSeconds();\n  \n  // Update pitch\n  const FRotator& CameraRotation = CameraComponent->GetComponentRotation();\n  const float NewPitch = FMath::Clamp(CameraRotation.Pitch + VectorValue.Y, CameraPitchRange.X, CameraPitchRange.Y);\n  const FRotator NewCameraRotator = FRotator(NewPitch, CameraRotation.Yaw, CameraRotation.Roll);\n  CameraComponent->SetWorldRotation(NewCameraRotator);\n  \n  // Update yaw\n  const FRotator& ActorRotation = GetActorRotation();\n  const float NewYaw = ActorRotation.Yaw + VectorValue.X;\n  const FRotator NewActorRotator = FRotator(ActorRotation.Pitch, NewYaw, ActorRotation.Roll);\n  SetActorRotation(NewActorRotator);\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"You should now be able to look around with the mouse (or gamepad). Feel free to adjust the sensitivity setting in your Pawn BP."}]},{"item":"55258799","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"(I've added a cube \"arm\" to the camera component of our Pawn to help visualize, as well as created a map to test future features)."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Move function"}]},{"type":"paragraph","children":[{"type":"span","value":"Next up is the Move function. The Pawn implementation is very minimal; most of the logic lies in the Movement Component."}]},{"type":"paragraph","children":[{"type":"span","value":"The Pawn implementation only needs to transform our local-space XY input into world-space for our movement component to consume. The code looks like this:"}]},{"code":"void ACactusPlayerPawn::OnInput_Move(const FInputActionValue& Value)\n{\n  const FVector2D RawInput = Value.Get<FVector2D>();\n  const FVector ForwardInput = RawInput.X * GetActorForwardVector();\n  const FVector RightInput = RawInput.Y * GetActorRightVector();\n  AddMovementInput(ForwardInput + RightInput);\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"AddMovementInput"},{"type":"span","value":" is a Pawn function that automatically pipes the input through to the first available Movement Component, which in our case is our "},{"type":"span","marks":["code"],"value":"USimpleMovementComponent"},{"type":"span","value":" that we've created in our Pawn constructor."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Movement Component"}]},{"type":"paragraph","children":[{"type":"span","value":"Let's move on to the Movement Component."}]},{"type":"paragraph","children":[{"type":"span","value":"First we need to override its tick function, which is the function that gets called every frame. Add to your Movement Component header file:"}]},{"code":"public:\n  virtual void TickComponent(float DeltaTime, ELevelTick TickType,\n                             FActorComponentTickFunction* ThisTickFunction) override;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Then add the implementation. Inside we need to add a few sanity checks before running the main logic:"}]},{"code":"void USimpleMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType,\n                                             FActorComponentTickFunction* ThisTickFunction)\n{\n  Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n  if (ShouldSkipUpdate(DeltaTime))\n  {\n    return;\n  }\n\n  if (!PawnOwner || !UpdatedComponent)\n  {\n    return;\n  }\n\n  // Handle movement\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Now we're ready to start moving."}]},{"type":"paragraph","children":[{"type":"span","value":"A Movement Component already has access to the root component it manages (in our case our Pawn Capsule Component) in the form of the variable "},{"type":"span","marks":["code"],"value":"UpdatedComponent"},{"type":"span","value":".  The component can be manipulated directly, but the Movement Component also has access to many helpful functions. One important function is "},{"type":"span","marks":["code"],"value":"MoveUpdatedComponent"},{"type":"span","value":" which as the name implies handles moving it."}]},{"type":"paragraph","children":[{"type":"span","value":"A Movement Component also has a variable called "},{"type":"span","marks":["code"],"value":"Velocity"},{"type":"span","value":" which can be used to calculate movement. It is helpful to treat it as actual physics velocity. Since Unreal Units (UU) are equivalent of centimeters, we'll use velocity as UU/s."}]},{"type":"paragraph","children":[{"type":"span","value":"When we're working with the velocity variable we also need to call "},{"type":"span","marks":["code"],"value":"UpdateComponentVelocity()"},{"type":"span","value":" at the end of a tick to handle the changes internally."}]},{"type":"paragraph","children":[{"type":"span","value":"First we need to grab our input provided previously in our Pawn by "},{"type":"span","marks":["code"],"value":"AddMovementInput()"},{"type":"span","value":". This is done by calling "},{"type":"span","marks":["code"],"value":"ConsumeInputVector()"},{"type":"span","value":"."}]},{"code":"const FVector& Input = ConsumeInputVector().GetClampedToMaxSize2D(1.0f);","type":"code","language":"cpp"},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"Note: the reason we clamp it is because otherwise we the magnitude larger than1 when moving diagonally, which will make us exceed our max speed (by ~1.4x or the square root of 2). This is less pronounced with a gamepad than with WASD because of how the joystick works but still present."}]},{"type":"paragraph","children":[{"type":"span","value":"This is actually in many older FPS games, and often considered a useful technique when speedrunning for example, so if you want that you can keep it. Otherwise we simply need to clamp the max size of our input vector."}]}]},{"type":"paragraph","children":[{"type":"span","value":"This input is then used to calculate a directional force, scaled by our desired movement speed."}]},{"code":"const FVector DesiredInputForce = Input * MoveSpeed;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"MoveSpeed"},{"type":"span","value":" is just a float that has been added to our Movement Component. The value equals how many Unreal units we move per second (cm/s). It is helpful to expose it as a "},{"type":"span","marks":["code"],"value":"UPROPERTY"},{"type":"span","value":" variable so we can change it in the editor. I've also added a constructor to set a default value:"}]},{"code":"public:\n  UPROPERTY(EditAnywhere, Category=\"Movement\")\n  float MoveSpeed;\n\n  USimpleMovementComponent();","type":"code","language":"cpp"},{"code":"USimpleMovementComponent::USimpleMovementComponent(): MoveSpeed(600.0f)\n{\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"The resulting "},{"type":"span","marks":["code"],"value":"DesiredInputForce"},{"type":"span","value":" is then added to our "},{"type":"span","marks":["code"],"value":"Velocity"},{"type":"span","value":", and we calculate a new vector, "},{"type":"span","marks":["code"],"value":"MovementDelta"},{"type":"span","value":" which will equal how much we move "},{"type":"span","marks":["emphasis"],"value":"this tick"},{"type":"span","value":":"}]},{"code":"Velocity += DesiredInputForce;\nconst FVector MovementDelta = Velocity * DeltaTime;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"We then call the relevant functions to update our actual location."}]},{"code":"const FRotator& Rotation = UpdatedComponent->GetComponentRotation();\nMoveUpdatedComponent(MovementDelta, Rotation, false);\nUpdateComponentVelocity();","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"Note that "},{"type":"span","marks":["code"],"value":"MoveUpdatedComponent"},{"type":"span","value":" requires a rotation as well, so we just grab our current rotation."}]},{"type":"paragraph","children":[{"type":"span","value":"Finally we also need to clear our "},{"type":"span","marks":["code"],"value":"Velocity"},{"type":"span","value":" at the start of a tick so that it doesn't accumulate, since we won't be implementing friction/deceleration right now."}]},{"code":"Velocity.X = 0;\nVelocity.Y = 0;","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"The final tick function looks like this:"}]},{"code":"void USimpleMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType,\n                                             FActorComponentTickFunction* ThisTickFunction)\n{\n  Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n  if (ShouldSkipUpdate(DeltaTime))\n  {\n    return;\n  }\n\n  if (!PawnOwner || !UpdatedComponent)\n  {\n    return;\n  }\n  \n  // Reset velocity\n  Velocity.X = 0;\n  Velocity.Y = 0;\n\n  // Calculate force\n  const FVector& Input = ConsumeInputVector().GetClampedToMaxSize2D(1.0f);\n  const FVector DesiredInputForce = Input * MoveSpeed;\n  Velocity += DesiredInputForce;\n  const FVector MovementDelta = Velocity * DeltaTime;\n\n  // Move\n  const FRotator& Rotation = UpdatedComponent->GetComponentRotation();\n  MoveUpdatedComponent(MovementDelta, Rotation, false);\n  UpdateComponentVelocity();\n}\n","type":"code","language":"cpp"},{"type":"heading","level":1,"children":[{"type":"span","value":"Results"}]},{"type":"paragraph","children":[{"type":"span","value":"We should be able to move around! However we are currently levitating and we can move through walls ðŸ‘»."}]},{"item":"55444906","type":"block"}]}},"blocks":[{"__typename":"ImageRecord","id":"55082369","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLChULDhQZGhkWDhEhEhENFxYZGBYVFiEdHy0vHSkoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLAg0OHBAQHDsoIigvLzs7Ozs7Oy87Oy8vLy8vLy87Oy87LzsvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAACAwAAAAAAAAAAAAAAAAADBgAEBf/EAB0QAAIDAAIDAAAAAAAAAAAAAAECAAMEETEFEiH/xAAWAQEBAQAAAAAAAAAAAAAAAAADBAL/xAAeEQABAwQDAAAAAAAAAAAAAAABAAZBAwQhUQIHEf/aAAwDAQACEQMRAD8AW9tiFPpg/HtX7dzN1WuU7lXHosF3AMqFXsmCPEfKi2DkhN74671kgMdzlByZJk3D12jNu2TC/9k=","srcSet":"https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.25&max-w=600 132w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.5&max-w=600 264w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.75&max-w=600 396w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&max-w=600 528w","webpSrcSet":"https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.25&fm=webp&max-w=600 132w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.5&fm=webp&max-w=600 264w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&dpr=0.75&fm=webp&max-w=600 396w,https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&fm=webp&max-w=600 528w","sizes":"(max-width: 528px) 100vw, 528px","src":"https://www.datocms-assets.com/77616/1660781073-fpmfs-pt2-input-action.png?auto=format&max-w=600","alt":null,"title":null,"width":528,"height":252,"aspectRatio":2.0952380952380953}}},{"__typename":"ImageRecord","id":"55423801","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBxASBgoNEhAHBgYNDg4QDgYGDhENDQgYFxkZGBYVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLBQUFEAUFEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABkADgMBIgACEQEDEQH/xAAWAAEBAQAAAAAAAAAAAAAAAAADBgH/xAAbEAACAgMBAAAAAAAAAAAAAAAAAwFBIjEyAv/EABQBAQAAAAAAAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCEd1ATaEbOcBtnQGtnINvrQjegWUB//9k=","srcSet":"https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.25&max-w=600 155w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.5&max-w=600 310w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.75&max-w=600 465w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&max-w=600 621w","webpSrcSet":"https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.25&fm=webp&max-w=600 155w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.5&fm=webp&max-w=600 310w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&dpr=0.75&fm=webp&max-w=600 465w,https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&fm=webp&max-w=600 621w","sizes":"(max-width: 621px) 100vw, 621px","src":"https://www.datocms-assets.com/77616/1660830153-fpmfs-pt2-input-mapping.png?auto=format&max-w=600","alt":null,"title":null,"width":621,"height":1099,"aspectRatio":0.565059144676979}}},{"__typename":"ImageRecord","id":"55082371","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgLEAoGCg8IBgoGBw0QCQYIBxEJFgcYFxMZGBYTFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDgsKEAoKEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAAAQIDBv/EABgQAQEBAQEAAAAAAAAAAAAAAAACEQMB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AOHv1nqLpWaBHQR09AXtluACl0AD/9k=","srcSet":"https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.25&max-w=600 153w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.5&max-w=600 307w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.75&max-w=600 461w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&max-w=600 615w","webpSrcSet":"https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.25&fm=webp&max-w=600 153w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.5&fm=webp&max-w=600 307w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&dpr=0.75&fm=webp&max-w=600 461w,https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&fm=webp&max-w=600 615w","sizes":"(max-width: 615px) 100vw, 615px","src":"https://www.datocms-assets.com/77616/1660830198-fpmfs-pt2-input-mapping-2.png?auto=format&max-w=600","alt":null,"title":null,"width":615,"height":602,"aspectRatio":1.021594684385382}}},{"__typename":"ImageRecord","id":"55258791","image":{"responsiveImage":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBg4IEggNDgcHDg0HDggODhEJDRENFxUZGBYVFhUaHysjGh0oHRUiJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLBQUFEAUFEC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAACAwAAAAAAAAAAAAAAAAAAAwEEBv/EABkQAAMBAQEAAAAAAAAAAAAAAAABAhEDBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDK9cwTK1k9qeCopgM6NSBW9FPAA//Z","srcSet":"https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.25&max-w=600 59w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.5&max-w=600 118w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.75&max-w=600 177w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&max-w=600 237w","webpSrcSet":"https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.25&fm=webp&max-w=600 59w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.5&fm=webp&max-w=600 118w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&dpr=0.75&fm=webp&max-w=600 177w,https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&fm=webp&max-w=600 237w","sizes":"(max-width: 237px) 100vw, 237px","src":"https://www.datocms-assets.com/77616/1660822248-fpmfs-pt2-input-testing.png?auto=format&max-w=600","alt":null,"title":null,"width":237,"height":115,"aspectRatio":2.0608695652173914}}},{"__typename":"WebmRecord","id":"55258799","video":{"title":"Camera look","alt":"First-person perspective looking around","video":{"muxPlaybackId":"zOikROWk5opml5o012cM1LNnWxvOT4hQv"}}},{"__typename":"WebmRecord","id":"55444906","video":{"title":null,"alt":null,"video":{"muxPlaybackId":"ulVSKAjhokdBArHs01Nyn4zzbMKrADtgB"}}}]}},"isPreview":false},"__N_SSG":true}