{"pageProps":{"siteMetainfo":{"headerTitle":"Ljung","headerSubtitle":".dev","pageTitlePrefix":"Ljung | "},"_site":{"globalSeo":{"siteName":"Ljung","fallbackSeo":{"title":"Ljung | Game Dev","description":"Indie Game Developer from Sweden ðŸŽ®"}}},"post":{"title":"Unreal Engine and Git: Separating content from code","description":"This is an experimental workflow for working with Unreal Engine and git - handling content and code separately.","seriesPrevious":null,"seriesNext":null,"content":{"value":{"schema":"dast","document":{"type":"root","children":[{"type":"paragraph","children":[{"type":"span","value":"Hej!"}]},{"type":"paragraph","children":[{"type":"span","value":"Git is a great version control system, but can struggle with large project, notably for lack of handling/scaling with large binary files. Those projects often opt for a different solution, like "},{"url":"https://www.plasticscm.com/","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"PlasticSCM"}]},{"type":"span","value":" or "},{"url":"https://www.perforce.com/products/helix-core","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Perforce"}]},{"type":"span","value":", however those versioning system work in a vastly different way, with their own advantages and drawbacks."}]},{"type":"paragraph","children":[{"type":"span","value":"Git however nowadays support blobs through Git LFS, which essentially store user-specified files outside the repo itself. Supposedly it's not a 100% solution to the problem, and GitHub has somewhat narrow limits for an Unreal project. This however led me to an idea for my specific use case. In essence, I:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Work on solo projects"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Want to track revisions"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Want to access my code on different machines"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Open-source the codebase of my projects"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Don't want to expose my content, which would make commercializing my open-source projects difficult"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"With this in mind I devised a structure and workflow to split content (essentially the "},{"type":"span","marks":["code"],"value":"Content"},{"type":"span","value":" folder but also some internal source material) and code/config (everything else)."}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"span","value":"Note: this workflow is still experimental and I'm testing it as I go through my solo projects."}]}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Architecture"}]},{"type":"paragraph","children":[{"type":"span","value":"An entire project is composed of two separate Git repositories: the \"Assets\" and the \"Main\" repository. The \"Assets\" repo is in turn added as a "},{"url":"https://git-scm.com/book/en/v2/Git-Tools-Submodules","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Git submodule"}]},{"type":"span","value":" of the \"Main\" repo. This simply means that folder inside \"Main\" is considered an entirely separate repo and is not included in the changes of the \"Main\" repo; the \"Main\" repo simply tracks which revision of the \"Assets\" repo is in use (and commits that tracking)."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Setup"}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Assets repo"}]},{"type":"paragraph","children":[{"type":"span","value":"The assets repo may live anywhere you like. For my purposes I put it on my NAS. My Unreal project is named \"Cactus\" and so my assets repo will be called \"Cactus_Assets\". From the directory where this repo will live run:"}]},{"code":"git init\ngit branch -m master main\ngit config --local receive.denyCurrentBranch updateInstead\ngit lfs install\ngit lfs track \"*.uasset\"\ngit lfs track \"*.umap\"\ngit add .gitattributes\ngit commit -m \"ðŸŽ‰ Init: setup\"","type":"code","language":"bash"},{"type":"paragraph","children":[{"type":"span","value":"This repo has to be non-bare to be used as a submodule. Because of this we also need to set the  "},{"type":"span","marks":["code"],"value":"denyCurrentBranch"},{"type":"span","value":" policy in order to push from our Main repo later on. Since the repo is non-bare this setting will force the working tree to be clean. This shouldn't be a problem as long as you treat it as a bare repo and don't work directly from the assets repo."}]},{"type":"paragraph","children":[{"type":"span","value":"You may also want to track additional file-types for LFS. For my scenario I store source files outside the Content folder, but if you store them together you might want to add \".fbx\", \".png\" etc."}]},{"type":"paragraph","children":[{"type":"span","value":"Renaming branch is optional but I like to match it with how GitHub names it."}]},{"type":"heading","level":2,"children":[{"type":"span","value":"Main repo"}]},{"type":"paragraph","children":[{"type":"span","value":"Remove the "},{"type":"span","marks":["code"],"value":"Content"},{"type":"span","value":" folder if not already removed. My preference is also to keep the Unreal project in a separate folder inside the Main repo, which will have implications when we add the Assets repo submodule. My structure looks like this:"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Cactus_Root"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Cactus"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Source"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Cactus.sln"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Cactus.uproject"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"etc."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"SourceArt"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"etc."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"From the root directory run:"}]},{"code":"git init\ngit branch -m master main\ngit submodule add -b main Y:\\Archive\\GameDev\\Cactus_Assets .\\Cactus\\Content\ngit config push.recurseSubmodules on-demand","type":"code","language":"bash"},{"type":"paragraph","children":[{"type":"span","value":"Note that "},{"type":"span","marks":["code"],"value":"Y:\\Archive\\GameDev\\Cactus_Assets"},{"type":"span","value":" is the full path to my Assets repo, and you have to rename \"Cactus\" in "},{"type":"span","marks":["code"],"value":".\\Cactus\\Content"},{"type":"span","value":" to what your project is named."}]},{"type":"paragraph","children":[{"type":"span","value":"Settings "},{"type":"span","marks":["code"],"value":"push.recurseSubmodules"},{"type":"span","value":" means that any commits not pushed on the Assets repo will be pushed before pushing Main repo commits. This is a best practice since the Main repo tracks and commits which revision of the Assets repo it is using, and thus the Assets repo commit has to be available before updating any remotes."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Workflow"}]},{"type":"paragraph","children":[{"type":"span","value":"Working with this setup is largely the same as a regular single repo. The difference is if you use Git commands from within the Content folder it will act upon the Assets repo, while anywhere else will act upon the Main repo."}]},{"type":"paragraph","children":[{"type":"span","value":"Any changes to the Content folder should be committed before related changes in the Main repo are committed, to ensure interoperability stays consistent. As you make commits and update the Assets repo the Main repo will see changes to a file pointing to the Content directory. This file should be committed, and simply tracks the Assets repo commit being used."}]},{"type":"paragraph","children":[{"type":"span","value":"Some IDE's (like VSCode) can show commit SHA changes between revisions. From CLI you can run "},{"type":"span","marks":["code"],"value":"git diff Cactus/Content"},{"type":"span","value":" (or your equivalent) to show the SHA change as well."}]},{"type":"heading","level":1,"children":[{"type":"span","value":"Misc"}]},{"type":"paragraph","children":[{"type":"span","value":"It is a good idea to also add a "},{"type":"span","marks":["code"],"value":".gitignore"},{"type":"span","value":" file to your Main repo. You can find a good ignore file on the "},{"url":"https://github.com/github/gitignore/blob/main/UnrealEngine.gitignore","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"GitHub gitignore repo"}]},{"type":"span","value":" which you should put next to your .uproject file (your equivalent of "},{"type":"span","marks":["code"],"value":"Cactus_Root/Cactus"},{"type":"span","value":"). Additionally you should add "},{"type":"span","marks":["code"],"value":"Content/*"},{"type":"span","value":" to that file so that you don't accidentally add content to the Main repo somehow."}]},{"type":"paragraph","children":[{"type":"span","value":""}]}]}},"blocks":[]}},"isPreview":false},"__N_SSG":true}